//=====================================================
Graph
//=====================================================
Класс (Graph.java) с внутренним подклассом Vertex.
Идея в том, что вершины хранятся в массиве для быстрого доступа по индексу. Каждая вершина помнит свой номер и номера вершин, в и из которых идут в нее ребра.
Свойства: 
	vertices 	-- набор всех вершин графа, массив, инициализируется при создании графа
	count 		-- число вершин
	sources, sinks 	-- ArrayList<Integer> номеров source, sink
	s1,s2 		-- ArrayList<Integer> результаты сортировки
	left 		-- количество неотсортированных вершин (для контроля)
	numberOfReversingEdges -- считается в процессе сортировки
	withoutSinks 	-- использовать sink или идти только от source
	lefttoright
	righttoleft 	-- число ребер -> и <- ,считаются в процессе cutwidth
	degree0, etc 	-- вершины со степенью (0, 1, -1, 2+, -2-) . Неудавшаяся идея ускорения findMaxVertex
Методы:
	info		-- перечисляет все вершины с IN и OUT ребрами
	cutwidth	-- считает суммарное число ребер в разрезах для перестановки
	fillSourcesAndSinks -- находит все source, sink, запихивает их в соответствующие списки и если передано true, то еще и заполняет degree0, etc
	recountDegreeDifference -- для работы degree0, etc
	findMaxVertex 	-- ищет вершину с макс разницей степеней и среди таких с макс степенью
	findMaxVertexNew-- то же самое, используя degree0, etc
	deleteVertex	-- удаляем все ребра из вершины, контролируем аналогичное про другие вершины. Добавляем source, sink, если таковые получаются. Если второй параметр true, то пересчитываем degree0, etc
			-- возвращаем номер последней source, последнего sink со знаком минус (еще -10 чтобы отличать от -1) или -1 если ни того ни сего не нашли
	sorting 	-- главная процедура сортировки (собственно алгоритм). параметр говорит, использовать degree0, etc или без них. Все вышеупомянутые процедуры сразу вызываются с этим параметром. По умолчанию false
	outputSorting	-- выводит на консоль порядок вершин в результате сортировки через запятую, плюс строчкой ниже пишет число reversing edges

	Забавный момент:пустой граф с 100 000 вершин сортируется 5 секунд в то время как
			цепочка из 100 000 вершин сортируется менее чем за 1 секунду.
//=====================================================
Vertex
//=====================================================
Свойства:
	id 		-- совпадает с номером вершины при создании в графе. требуется для быстрого доступа по индексу через массив вершин
	inEdges 	-- ArrayList<Integer> номера вершин, из которых входят ребра
	outEdges 	-- то же про выходящие ребра
	indegree	-- входящая степень
	outdegree	-- исходящая степень
Методы:
	ClearEdges	-- удаляет все ребра из вершины и обнуляет степени




//=====================================================
GraphSaveLoad
//=====================================================
Запись/чтение графа из текстового файла.
Формат файла
x
v1 v2 v3 ... vn -1

Первая строчка число вершин в графе или -1, если это не первый файл для этого графа (чтобы хранить большой граф несколькими файлами)
Вторая и далее строчки -- это последовательности вершин, связанных ребрами. В конце строчки стоит маркер -1, обозначающий конец строки.
Пока граф записывает каждое ребро на отдельной строчке (читает уже цепочками), но, возможно, в будущем он будет писать цепочки.

//=====================================================
Permutation
//=====================================================
Перестановка. 
Все свойства приватные.
Свойства:
	permutation	-- сама перестановка хранится тут как ArrayList<Integer>
	cutwidth	-- суммарное число ребер в разрезах. Получается применением метода cutwidth графа Graph и далее getter-setter механики
	cutwidthAverage	-- среднее число ребер в разрезах. пересчитывается при присвоении cutwidth
Методы:
	randomSguffle	-- переставляет числа в случайном порядке. на вход требует long для рандомайзера
	randomSwap	-- меняет местами два случайных числа
	viewPermutation	-- показывает перестановку плюс два других свойства

//=====================================================
Evolution
//=====================================================
Эволюционируем перестановки
Свойства:
	random		-- чтобы передавать перестановке
	parents		-- ArrayList<Permutation> родители. Задаются как случайные перестановки, если дать на вход граф или как много копий перестановки, если дать на вход ее
Методы:
	evolute		-- главный метод. на вход: граф по которому считать cutwidth, число детей на каждом шагу и число шагов (число родителей задается при создании объекта)
			-- делаем три случайных перестановки у каждого родителя и получаем сколько заказывали случайных детей. выбираем (число родителей) лучших и повторяем!

	Вопрос в том, как проводить генетический отбор. Сейчас в граф для сортировки добавляется очень много одинаковых перестановок и это может искажать картину. Кроме того
неясно, следует ли отбирать среди детей только тех, кто лучше родителей (грозит отсутствием детей в некоторых случаях) или оставлять как сейчас. Текущая версия для большого числа
вершин при малом числе родителей/детей начинает деградировать, если начинать ее с идеальной расстановки.

//=====================================================
Test...
//=====================================================
Много тестов для отработки алгоритмов и работы функций.
Test<число>_<число> -- создаются графы с <число> вершин и <число> ребер (из бумажных примеров) и на них тестируется сортировка, эволюция и т.д.
Test1000_999 -- тестируем макс размер графа. Работает до 18М вершин. Сам граф -- простая цепочка
Text25000_... -- тестируем работу findMaxVertex при большом числе циклов

Test20_29 хорошо показывает разницу между cutwidth и reversing edges:
В графе в лучшем случае 4 reversing edges при cutwidth 100 (average 5)
При этом минимальный cutwidth 70, но в такой перестановке соотношение ребер 16/13

TestDegradation показывает проблемы эволюционного алгоритма (по карйней мере в текущем виде):
он не может улучшить 17 16 15 14 13 18 19 12 11 ... 0 потому что почти любые 1-3 перестановки ухудшают ситуацию (тем более было бы верно про соседние)





































//=====================================================
Спасибо за внимание!
//=====================================================
