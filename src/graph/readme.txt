//=====================================================
Graph
//=====================================================
Класс (Graph.java) с внутренним подклассом Vertex.
Идея в том, что вершины хранятся в массиве для быстрого доступа по индексу. Каждая вершина помнит свой номер и номера вершин, в и из которых идут в нее ребра.
Свойства: 
	vertices 	-- набор всех вершин графа, HashMap
	edges 		-- набор ребер графа, класс Edges
	nextEdgeKey	-- чтобы присваивать номера ребрам
	count 		-- число вершин
	sources, sinks 	-- ArrayList<Integer> номеров source, sink
	s1,s2 		-- ArrayList<Integer> результаты сортировки
	left 		-- количество неотсортированных вершин (для контроля)
	numberOfReversingEdges -- считается в процессе сортировки
	weightOfReversingEdges -- вес обратных ребер
	lefttoright
	righttoleft 	-- число ребер -> и <- ,считаются в процессе cutwidth
	
Методы:
	info		-- перечисляет все вершины с IN и OUT ребрами
	cutwidth	-- считает суммарное число ребер в разрезах для перестановки
	fillSourcesAndSinks -- находит все source, sink, запихивает их в соответствующие списки 
	findMaxVertex 	-- ищет вершину с макс разницей степеней и среди таких с макс степенью
	deleteVertex	-- удаляем все ребра из вершины, контролируем аналогичное про другие вершины. Добавляем source, sink, если 			таковые получаются. Возвращаем номер последней source, последнего sink со знаком минус (еще -10 чтобы 		отличать от -1) или -1 если ни того ни сего не нашли
	sorting 	-- главная процедура сортировки (собственно алгоритм). 
	outputSorting	-- выводит на консоль порядок вершин в результате сортировки через запятую, плюс строчкой ниже пишет число 			reversing edges

	
//=====================================================
Node, Edge, Edges
//=====================================================

...under construction...

//=====================================================
GraphSaveLoad
//=====================================================
Запись/чтение графа из текстового файла.
Формат файла
x
v1 v2 v3 ... vn -1

Первая строчка число вершин в графе или -1, если это не первый файл для этого графа (чтобы хранить большой граф несколькими файлами)
Вторая и далее строчки -- это последовательности вершин, связанных ребрами. В конце строчки стоит маркер -1, обозначающий конец строки.
Пока граф записывает каждое ребро на отдельной строчке (читает уже цепочками), но, возможно, в будущем он будет писать цепочки.

//=====================================================
Permutation
//=====================================================
Перестановка. 
Все свойства приватные.
Свойства:
	permutation	-- сама перестановка хранится тут как ArrayList<Integer>
	cutwidth	-- суммарное число ребер в разрезах. Получается применением метода cutwidth графа Graph и далее getter-setter механики
	cutwidthAverage	-- среднее число ребер в разрезах. пересчитывается при присвоении cutwidth
Методы:
	randomShuffle	-- переставляет числа в случайном порядке. на вход требует long для рандомайзера
	randomSwap	-- меняет местами два случайных числа
	viewPermutation	-- показывает перестановку плюс два других свойства
	toString
	compareTo	-- переопределены

//=====================================================
Evolution
//=====================================================
Эволюционируем перестановки
Свойства:
	random		-- чтобы передавать перестановке
	parents		-- ArrayList<Permutation> родители. Задаются как случайные перестановки, если дать на вход граф или как много копий перестановки, если дать на вход ее
Методы:
	evolute		-- главный метод. на вход: граф по которому считать cutwidth, число детей на каждом шагу и число шагов (число родителей задается при создании объекта)
			-- делаем три случайных перестановки у каждого родителя и получаем сколько заказывали случайных детей. выбираем (число родителей) лучших и повторяем!

	Вопрос в том, как проводить генетический отбор. Сейчас в граф для сортировки добавляется очень много одинаковых перестановок и это может искажать картину. Кроме того
неясно, следует ли отбирать среди детей только тех, кто лучше родителей (грозит отсутствием детей в некоторых случаях) или оставлять как сейчас. Текущая версия для большого числа
вершин при малом числе родителей/детей начинает деградировать, если начинать ее с идеальной расстановки.






































//=====================================================
Спасибо за внимание!
//=====================================================
